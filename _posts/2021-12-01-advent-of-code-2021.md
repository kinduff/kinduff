---
title: Advent of Code 2021
date: 2021-12-03
description: >-
  This live post will be updated with my solutions for the AoC 2021.
---

It's december again, it feels like the last AoC was a couple months ago. This blog post will be updated whenever I solve a puzzle. You can bookmark it if you want to follow or subscribe to the [RSS Feed](/feed.xml).

> Advent of Code is an Advent calendar of small programming puzzles for a variety of skill sets and skill levels that can be solved in any programming language you like.

More on [their about page](https://adventofcode.com/2021/about).

I'm really trying to finish this year, I'll be on vacation. I'm hoping for the best because I really love these kind of puzzles.

You can also visit my progress and read the source of my solutions in [the GitHub repository](https://github.com/kinduff/advent2021).

## Table of Contents

* TOC
{:toc}

## Template

I use this template on the repository I use to solve the puzzles. It's quite simple really.

One method for each part, assertions and data to verify the hint provided, and a method to read the final data input.

```ruby
# utils.rb
require 'test/unit'
include Test::Unit::Assertions

def psol(part, solution)
  puts "Solution for part #{part}: #{solution}"
end

# template.rb
require_relative '../lib/utils'

input = IO.readlines('day01.txt', chomp: true)

test_input = []

# --- Part One ---

def solve_1(input)
end

assert_equal solve_1(test_input), 7
psol '1', solve_1(input)

# --- Part Two ---

def solve_2(input)
end

assert_equal solve_2(test_input), 5
psol '2', solve_2(input)
```

## Solutions

### Day 1: Sonar Sweep

```ruby
test_input = [199, 200, 208, 210, 200, 207, 240, 269, 260, 263]
```

#### Part 1

```ruby
def solve_1(input)
  sum = 0
  input.each_with_index do |m, i|
    sum += 1 if m > input[i - 1]
  end
  sum
end

assert_equal solve_1(test_input), 7
psol '1', solve_1(input)
```

#### Part 2

```ruby
def solve_2(input)
  sum = 0
  input.each_with_index do |m, i|
    next if input[i + 3] == nil
    window_a = [m, input[i + 1], input[i + 2]].inject(:+)
    window_b = [input[i + 1], input[i + 2], input[i + 3]].inject(:+)
    sum += 1 if window_b > window_a
  end
  sum
end

assert_equal solve_2(test_input), 5
psol '2', solve_2(input)
```

### Day 2: Dive!

```ruby
test_input = [
  "forward 5",
  "down 5",
  "forward 8",
  "up 3",
  "down 8",
  "forward 2",
]
```

#### Part 1

```ruby
def solve_1(input)
  x, y = 0, 0
  input.each do |line|
    direction, distance = line.split
    case direction
    when 'up'
      y -= distance.to_i
    when 'down'
      y += distance.to_i
    when 'forward'
      x += distance.to_i
    end
  end
  x * y
end

assert_equal solve_1(test_input), 150
psol '1', solve_1(input)
```

#### Part 2

```ruby
def solve_2(input)
  x, y, z = 0, 0, 0
  input.each do |line|
    direction, distance = line.split
    case direction
    when 'up'
      z -= distance.to_i
    when 'down'
      z += distance.to_i
    when 'forward'
      x += distance.to_i
      y += z * distance.to_i
    end
  end
  x * y
end

assert_equal solve_2(test_input), 900
psol '2', solve_2(input)
```

### Day 3: Binary Diagnostic

```ruby
test_input = %w(
  00100
  11110
  10110
  10111
  10101
  01111
  00111
  11100
  10000
  11001
  00010
  01010
)
```

#### Part 1

```ruby
def solve_1(input)
  gama = []
  epsilon = []
  input.first.size.times do |i|
    column = input.map { |line| line[i] }
    values = { 0 => column.count('0'), 1 => column.count('1') }.sort_by { |_k, v| v }
    epsilon << values[0][0]
    gama << values[1][0]
  end

  gama_rate = gama.join('').to_i(2)
  epsilon_rate = epsilon.join('').to_i(2)

  [gama_rate, epsilon_rate].inject(:*)
end

assert_equal solve_1(test_input), 198
psol '1', solve_1(input)
```

#### Part 2

```ruby
def solve_2(input)
  calculate = -> (input, i, inv = false) do
    column = input.map { |line| line[i] }
    values = { 0 => column.count('0'), 1 => column.count('1') }.sort_by { |_k, v| v }

    values.reverse! if inv

    result = input.select { |line| line[i] == values[1][0].to_s }
    return result.first if result.size == 1

    calculate.call(result, i + 1, inv)
  end

  oxygen = calculate.call(input, 0).to_i(2)
  co2 = calculate.call(input, 0, true).to_i(2)

  [oxygen, co2].inject(:*)
end

assert_equal solve_2(test_input), 230
psol '2', solve_2(input)
```
